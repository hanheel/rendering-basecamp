# 🚀 1단계 Next.js 로 Hybrid Rendering 구현하기
## 🕵️ 셀프 리뷰

### 제출 전 체크 리스트

- [ ] 기능 요구 사항을 모두 구현했고, 정상적으로 동작하는지 확인했나요?
- [ ] 배포한 데모 페이지에 정상적으로 접근할 수 있나요?
  - 배포 링크 기입: **\_\_**
  
## 🧠 리뷰를 통한 생각 나눔

1. 성능 개선 - Chrome performance 에서 Fast 4G 기준 LCP 를 측정하고, 전후 결과를 비교한다.

2. Open Graph Tag 개선 - `/detail/:id` 를 공유했을 때, 영화 상세 정보가 보이는지 확인한다.

3. [선택] SEO 개선 - 사이트 페이지 하나하나가 검색 결과로 나오는지 확인한다.

4. 유저가 사이트에 접속했을 때, 브라우저가 HTML 을 요청하는 것부터 시작하여, 유저가 정상적으로 인터랙션을 하기까지의 과정을 그림으로 표현하고 설명해보아요. SSR 와 CSR 모두 그림과 설명이 필요합니다. (Browser, S3, SSR Server, TMDB Server 등의 요소를 활용하여 표현합니다.)

  ### CSR
  
  <img width="470" height="678" alt="image" src="https://github.com/user-attachments/assets/8a016c24-3b16-410c-884b-f998c8fc6b5b" />
  
  
  브라우저가 단순히 html + JS를 받고, 그 JS가 실행되며 화면에 렌더링 되는 것으로, 렌더링 책임이 온전히 브라우저에 있습니다.
  
  1. **브라우저 index.html 요청**
      1. 유저 접속
      2. 브라우저가 정적 파일 서버 (ex. S3/Cloudfront)에 index.html 요청
      3. 정적 파일 서버가 브라우저에 index.html 전송
          - 위 index.html은 div id=”root”를 포함한 HTML 및 JS 파일 번들 경로를 담음
  2. **HTML 파싱 / JS 번들 다운로드**
      - 응답 받은 html 파일을 위에서부터 차례로 읽으며 해석하며 DOM 트리를 구성함
      - `<script>` 태그를 만나기 전까지의 요소들이 DOM에 추가됨
      - html 파일을 읽는 도중 `<script>`태그를 만난 경우 HTML 파싱 중단, JS 파일 다운로드 및 시작
  3. **렌더트리 생성 / 첫 화면 렌더링**
      - 다운로드한 JS 번들 실행
      - 리액트 앱의 진입 코드(초기화 코드)가 실행되어 가상 DOM을 생성하고 실제 DOM에 반영, 브라우저의 DOM 트리 갱신
      - DOM이 갱신된 후 브라우저는 이를 기반으로 렌더 트리 갱신, 화면에 컴포넌트를 그림
  4. **데이터 Fetch**
      - 리액트 앱이 실행 된 후, 필요한 데이터를 서버에 요청 (Ex. TMDB Server)
  5. **유저 인터렉션 가능** 
      - 필요한 데이터, 상태, 의존 로직이 모두 준비되어 실제 서비스 동작이 가능
          - 데이터 Fetch 가 끝나지 않은 상황에서도 기능적으로 버튼 클릭 등의 인터렉션이 가능하나, 비즈니스 로직 레벨에서의 의도가 있는 인터렉션은 모든 데이터가 준비된 이후에 가능

  ### SSR
  
  <img width="756" height="570" alt="image" src="https://github.com/user-attachments/assets/fca4afaf-7b2b-4d45-8e3f-5f464516d02e" />
  
  
  1. **SSR 서버에 index.html 요청**
      1. 유저 접속
      2. 브라우저가 SSR서버에 index.html 요청
  2. **SSR서버가 외부 서버 (Ex. TMDB)에 필요한 데이터 요청**
      - 요청한 데이터를 받아 HTML 문서 내부에 JSON 형식으로 삽입
  3. **SSR서버가 HTML 문서를 브라우저에 전송**
      - 위 HTML 문서에는 기존 HTML 구조에 서버 데이터를 JSON 형식으로 삽입한 것이 합쳐져 있음
  4. **HTML 파싱 + JS 번들 다운로드 및 첫 화면 렌더링**
      - HTML 파싱 + JS 번들 다운로드 후 렌더 트리를 그려 첫 화면 노출
      - 서버 데이터가 함께 있는 상태로 화면을 제공할 수 있음
      - 이벤트 핸들러 등이 포함된 JS 실행 전이므로 인터렉션은 불가능
  5. **JS 번들 실행 + Hydration**
      - JS 번들이 실행되면서 내부의 리액트 코드 동작, 그 과정 속에서 Hydration 실행
      
      **Hydration : 브라우저가 서버에서 전달받은 HTML(DOM)과 리액트의 가상DOM을 비교한 후 필요한 부분만 활성화**
      
      1. 리액트가 클라이언트에서 실행될 때 SSR서버에서 전달한 HTML을 기반으로 가상 DOM 생성
      2. 브라우저가 그린 DOM과 가상 DOM을 비교, 구조가 불일치하는 부분만 다시 렌더링
      3. 각 노드에 이벤트 핸들러와 내부 상태 연결
    
      <br /><br /><br />

5. 위 그림을 참고하여, SSR 이 CSR 에 비해 로딩 성능이 더 빠른 이유를 써보아요.

SSR은 브라우저가 화면을 그리기 시작할 수 있는 시점이 CSR에 비해 앞당겨집니다.
CSR에서는 JS가 완전히 실행돼야 첫 화면이 렌더링 될 수 있습니다. 따라서 LCP 지연이 발생합니다. 하지만 SSR에서는 JS 실행 전에 이미 서버에서 필요한 데이터를 포함한 index.html을 내려주기 때문에 브라우저는 이를 바로 파싱하여 첫 화면을 그릴 수 있습니다. 따라서 초기 화면을 사용자에게 보여주는 시점이 CSR에 비해 훨씬 빨라지게 됩니다.

6. SSR 은 동적 컨텐츠를 검색 엔진에 등록할 수 있고, CSR 은 그게 어려운 이유를 써보아요.

SSR에서는 서버가 요청을 받을 때마다 React 컴포넌트를 실행하여 HTML을 생성합니다. 이때 서버는 클라이언트로 보내기 전에 데이터를 미리 가져오고(meta 정보 포함), 그 데이터를 이용해 <head> 내부의 <title>, <meta> 태그를 동적으로 삽입할 수 있습니다.
CSR에서는 우선 빈 HTML을 실행하고, JS가 실행 이후 렌더링 됩니다. 물론 데이터를 fetch한 이후에 DOM에 직접 접근하여 이를 변경할 수도 있습니다. 하지만 검색엔진은 페이지의 JS를 직접 실행하지 않기 때문에 이 변경을 감지하지 못하고 결과적으로 초기의 메타태그만 읽게 됩니다. 따라서 SEO 에는 전혀 도움을 주지 못합니다.

8. 어려웠던 트러블 슈팅이 있었다면 써 보세요.

9. 논의하고 싶은 것이 있다면 써 주세요.
